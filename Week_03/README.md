# 学习总结(week03)

​         第三周由于个人原因导致学习时间少，好多问题还没有去刷，在后续的时间里我会慢慢补上，第三周是分治、回溯；深度优先DFS、广度优先BFS；贪心算法。本质来说还是递归，学习了老师的模板和解题思想后，但是复杂问题还是喜欢先人肉递归。通过前三周的学习，我也是有进步的，学会了很多解决问题的思路，目前还无法全部掌握，只要多过变数，我相信慢慢就会理解了。

> 分治、回溯

回溯法采用试错思想，尝试分部的去解决一个问题。在分部解决问题的过程中，当他通过尝试发现现有的分步答案不能得到有效的正确的解答时，他将取消上一步甚至上几步计算，再通过其他可能分部解答再次尝试寻找问题的答案。

在反复上述步骤后可能出现两种情况:

找到一个可能存在的正确答案;

在尝试了所有可能的分步方法后宣告该问题没有答案;

> 深度优先DFS、广度优先BFS

DFS借助栈实现

BFS借助队列实现

> 贪心算法

贪心算法是一种在每一步选择中都采取在当前状态下最优的选择。

贪心算法和动态规划的不同在于他对每个子问题的解决方案都做出选择，不能回退。动态规划会保留以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

## 二分查找，寻找半有序数组中无序的地方

```
 //使用二分查找法
 //找到半有序数组中无序的地方
 public int findDisorder(int[] nums) {
        int n = nums.length;
        if (nums == null || n == 0) return -1;
        int left = 0, right = n - 1;
        if (n == 1 || nums[left] < nums[right]) return nums[0];
        while (right >= left) {
            int mid = (left + right) / 2;
            //是否是有序断开的位置
            if (mid > 0 && nums[mid - 1] > nums[mid]) return nums[mid];
            if (nums[mid] > nums[mid + 1]) return nums[mid + 1];
            //双指针移动
            if (nums[0] < nums[mid]) left = mid + 1;
            else right = mid - 1;
        }
        return -1;
    }
```

